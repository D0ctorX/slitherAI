<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>AI Slither Learning - Evolution Pro</title>
    <style>
        body { margin: 0; background: #222; color: white; font-family: sans-serif; display: flex; }
        #sidebar { width: 250px; background: #333; padding: 20px; border-right: 2px solid #444; }
        canvas { flex-grow: 1; background: #111; }
        .stat-box { background: #444; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
        input { width: 80%; padding: 5px; margin-top: 5px; }
        button { cursor: pointer; background: #28a745; color: white; border: none; padding: 10px; width: 100%; margin-top: 10px; border-radius: 5px; }
        button:hover { background: #218838; }
        #status { color: #ffc107; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Contr√¥les</h2>
    <div class="stat-box">
        G√©n√©ration: <span id="gen">1</span><br>
        Record: <span id="maxScore">0</span>
    </div>
    
    <div class="stat-box">
        <label>It√©rations rapides :</label>
        <input type="number" id="iterInput" value="10" min="1">
        <button onclick="runFastForward()">Lancer Simulation</button>
        <div id="status"></div>
    </div>

    <div id="livesInfo"></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth - 250;
canvas.height = window.innerHeight;

const CONFIG = {
    numSnakes: 6,
    numFood: 30,
    mutationRate: 0.1,
    maxLives: 3
};

function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }

class NeuralNetwork {
    constructor(weights) {
        this.weights = weights || Array.from({length: 7}, () => Math.random() * 2 - 1);
    }
    predict(inputs) {
        let sum = 0;
        inputs.forEach((val, i) => sum += val * this.weights[i]);
        return (sigmoid(sum) - 0.5) * 0.2;
    }
    mutate() {
        return new NeuralNetwork(this.weights.map(w => 
            Math.random() < CONFIG.mutationRate ? w + (Math.random() * 2 - 1) * 0.3 : w
        ));
    }
}

class Snake {
    constructor(brain) {
        this.brain = brain || new NeuralNetwork();
        this.fullReset();
    }

    fullReset() {
        this.lives = CONFIG.maxLives;
        this.score = 0;
        this.distanceTraveled = 0;
        this.respawn();
    }

    respawn() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.angle = Math.random() * Math.PI * 2;
        this.radius = 10;
        this.tail = [{x: this.x, y: this.y}];
        this.length = 5;
        this.isAlive = true;
    }

    update() {
        if (!this.isAlive) return;

        let inputs = [this.x/canvas.width, this.y/canvas.height, Math.cos(this.angle), Math.sin(this.angle), 0, 0, 0];
        let turn = this.brain.predict(inputs);
        this.angle += turn;

        this.x += Math.cos(this.angle) * 4;
        this.y += Math.sin(this.angle) * 4;
        this.distanceTraveled++;

        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.loseLife();
        }

        this.tail.unshift({x: this.x, y: this.y});
        if (this.tail.length > this.length) this.tail.pop();
    }

    loseLife() {
        this.lives--;
        if (this.lives > 0) {
            this.respawn();
        } else {
            this.isAlive = false;
        }
    }

    draw(index) {
        if (!this.isAlive) return;
        ctx.beginPath();
        ctx.fillStyle = `hsl(${(index * 60)}, 70%, 50%)`;
        this.tail.forEach(p => ctx.arc(p.x, p.y, this.radius, 0, Math.PI*2));
        ctx.fill();
        ctx.closePath();
    }
}

let snakes = Array.from({length: CONFIG.numSnakes}, () => new Snake());
let foods = Array.from({length: CONFIG.numFood}, () => ({x: Math.random()*canvas.width, y: Math.random()*canvas.height}));
let generation = 1;
let highScore = 0;
let isSimulating = false;

function evolve() {
    snakes.sort((a, b) => (b.distanceTraveled + b.score * 200) - (a.distanceTraveled + a.score * 200));
    let bestBrain = snakes[0].brain;
    if (snakes[0].score > highScore) highScore = snakes[0].score;

    snakes = snakes.map((s, i) => {
        if (i === 0) return new Snake(bestBrain);
        return new Snake(bestBrain.mutate());
    });

    generation++;
    updateUI();
}

function updateUI() {
    document.getElementById('gen').innerText = generation;
    document.getElementById('maxScore').innerText = highScore;
    let livesHtml = "<b>Vies restantes :</b><br>";
    snakes.forEach((s, i) => {
        livesHtml += `Joueur ${i+1}: ${s.isAlive ? '‚ù§Ô∏è'.repeat(s.lives) : 'üíÄ'}<br>`;
    });
    document.getElementById('livesInfo').innerHTML = livesHtml;
}

async function runFastForward() {
    if (isSimulating) return;
    const iterations = parseInt(document.getElementById('iterInput').value);
    isSimulating = true;
    document.getElementById('status').innerText = "Simulation en cours...";

    // On utilise setTimeout pour ne pas geler le navigateur
    for (let i = 0; i < iterations; i++) {
        while (snakes.some(s => s.isAlive)) {
            snakes.forEach(s => {
                if (s.isAlive) {
                    s.update();
                    foods.forEach(f => {
                        if (Math.hypot(s.x-f.x, s.y-f.y) < 15) {
                            s.score++; s.length++;
                            f.x = Math.random()*canvas.width; f.y = Math.random()*canvas.height;
                        }
                    });
                }
            });
        }
        evolve();
        if (i % 5 === 0) await new Promise(r => setTimeout(r, 1)); // Petite pause pour l'UI
    }

    isSimulating = false;
    document.getElementById('status').innerText = "Termin√© !";
}

function loop() {
    if (!isSimulating) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (!snakes.some(s => s.isAlive)) {
            evolve();
        }

        snakes.forEach((s, i) => {
            s.update();
            s.draw(i);
            
            foods.forEach(f => {
                ctx.fillStyle = "#0f0";
                ctx.beginPath(); ctx.arc(f.x, f.y, 5, 0, Math.PI*2); ctx.fill();
                if (s.isAlive && Math.hypot(s.x-f.x, s.y-f.y) < 15) {
                    s.score++; s.length++;
                    f.x = Math.random()*canvas.width; f.y = Math.random()*canvas.height;
                }
            });
        });
        updateUI();
    }
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
