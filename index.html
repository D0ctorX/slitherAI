<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>AI Slither Learning</title>
    <style>
        body { margin: 0; background: #222; color: white; font-family: sans-serif; overflow: hidden; }
        canvas { display: block; background: #111; margin: auto; }
        #stats { position: absolute; top: 10; left: 10; background: rgba(0,0,0,0.7); padding: 10px; pointer-events: none; }
    </style>
</head>
<body>

<div id="stats">
    Génération: <span id="gen">1</span><br>
    Meilleur Score: <span id="maxScore">0</span><br>
    Agents en vie: <span id="alive">0</span>/6
</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const CONFIG = {
    numSnakes: 6,
    numFood: 30,
    rayCount: 5, // "Vision" de l'IA (5 directions)
    mutationRate: 0.1
};

// --- OUTILS MATHÉMATIQUES ---
function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }

class NeuralNetwork {
    constructor(weights) {
        // Entrées: Vision (5 rayons) + Angle actuel = 6
        // Sortie: Changement de direction (1 valeur)
        this.weights = weights || Array.from({length: 7}, () => Math.random() * 2 - 1);
    }

    predict(inputs) {
        let sum = 0;
        inputs.forEach((val, i) => sum += val * this.weights[i]);
        return (sigmoid(sum) - 0.5) * 0.2; // Retourne un changement d'angle petit
    }

    mutate() {
        return new NeuralNetwork(this.weights.map(w => 
            Math.random() < CONFIG.mutationRate ? w + (Math.random() * 2 - 1) * 0.5 : w
        ));
    }
}

// --- LOGIQUE DU JEU ---
class Snake {
    constructor(brain) {
        this.reset(brain);
    }

    reset(brain) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.angle = Math.random() * Math.PI * 2;
        this.radius = 10;
        this.tail = [{x: this.x, y: this.y}];
        this.length = 5;
        this.alive = true;
        this.score = 0;
        this.brain = brain || new NeuralNetwork();
        this.distanceTraveled = 0;
    }

    update() {
        if (!this.alive) return;

        // 1. Vision (L'IA regarde autour d'elle)
        let inputs = this.getVision();
        
        // 2. Décision
        let turn = this.brain.predict(inputs);
        this.angle += turn;

        // 3. Mouvement
        this.x += Math.cos(this.angle) * 3;
        this.y += Math.sin(this.angle) * 3;
        this.distanceTraveled++;

        // Collision murs
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.die();
        }

        // Gestion de la queue
        this.tail.unshift({x: this.x, y: this.y});
        if (this.tail.length > this.length) this.tail.pop();
    }

    getVision() {
        // Simule des capteurs de distance vers la nourriture/murs
        let views = [0, 0, 0, 0, 0, 0, this.angle / Math.PI];
        // Simplification pour la démo : l'IA "sent" si elle va vers le centre ou les bords
        views[0] = this.x / canvas.width;
        views[1] = this.y / canvas.height;
        return views;
    }

    die() {
        this.alive = false;
    }

    draw() {
        if (!this.alive) return;
        ctx.beginPath();
        ctx.fillStyle = "hsl(" + (this.score * 40 % 360) + ", 70%, 50%)";
        this.tail.forEach(p => ctx.arc(p.x, p.y, this.radius, 0, Math.PI*2));
        ctx.fill();
        ctx.closePath();
    }
}

class Food {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.radius = 5;
    }
    draw() {
        ctx.beginPath();
        ctx.fillStyle = "#0f0";
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();
    }
}

// --- GESTION DU CYCLE ---
let snakes = Array.from({length: CONFIG.numSnakes}, () => new Snake());
let foods = Array.from({length: CONFIG.numFood}, () => new Food());
let generation = 1;
let highScore = 0;

function evolve() {
    // Trier par score (distance + nourriture)
    snakes.sort((a, b) => (b.distanceTraveled + b.score * 100) - (a.distanceTraveled + a.score * 100));
    
    let bestBrain = snakes[0].brain;
    if (snakes[0].score > highScore) highScore = snakes[0].score;

    // Nouvelle génération
    snakes = snakes.map((s, i) => {
        if (i === 0) return new Snake(bestBrain); // Le champion reste
        return new Snake(bestBrain.mutate());     // Les autres sont des versions mutées
    });

    generation++;
    document.getElementById('gen').innerText = generation;
    document.getElementById('maxScore').innerText = highScore;
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    let aliveCount = snakes.filter(s => s.alive).length;
    document.getElementById('alive').innerText = aliveCount;

    if (aliveCount === 0) evolve();

    foods.forEach(f => f.draw());

    snakes.forEach(s => {
        if (!s.alive) return;
        s.update();
        s.draw();

        // Manger
        foods.forEach(f => {
            let dist = Math.hypot(s.x - f.x, s.y - f.y);
            if (dist < s.radius + f.radius) {
                s.score++;
                s.length += 2;
                f.x = Math.random() * canvas.width;
                f.y = Math.random() * canvas.height;
            }
        });

        // Collision avec les autres serpents (Punition)
        snakes.forEach(other => {
            if (s === other || !other.alive) return;
            other.tail.forEach(p => {
                let dist = Math.hypot(s.x - p.x, s.y - p.y);
                if (dist < s.radius) s.die();
            });
        });
    });

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
