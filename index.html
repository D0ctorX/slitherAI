<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>AI Slither - Vision & Intelligence</title>
    <style>
        body { margin: 0; background: #1a1a1a; color: white; font-family: sans-serif; display: flex; overflow: hidden; }
        #sidebar { width: 300px; background: #2c3e50; padding: 20px; border-right: 3px solid #1a1a1a; height: 100vh; }
        canvas { flex-grow: 1; background: #000; cursor: crosshair; }
        .stat-box { background: #34495e; padding: 15px; margin-bottom: 15px; border-radius: 8px; border-left: 5px solid #27ae60; }
        button { cursor: pointer; background: #27ae60; color: white; border: none; padding: 12px; width: 100%; border-radius: 5px; font-weight: bold; font-size: 1.1em; }
        button:hover { background: #2ecc71; }
        #playerStats { font-family: monospace; }
        .vision-debug { color: #bdc3c7; font-size: 0.8em; margin-top: 5px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>üß† IA Vision V2</h2>
    <div class="stat-box">
        G√©n√©ration: <span id="gen">1</span><br>
        Meilleure Taille: <span id="maxScore">0</span>
    </div>
    
    <div class="stat-box">
        <label>Bond technologique (G√©n√©rations) :</label>
        <input type="number" id="iterInput" value="10" min="1" style="width:100%; margin:10px 0; padding:8px;">
        <button onclick="runFastForward()">Acc√©l√©rer l'√âvolution</button>
        <div id="status" style="color:#f1c40f; margin-top:10px; text-align:center;"></div>
    </div>

    <div id="playerStats"></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth - 300;
canvas.height = window.innerHeight;

const CONFIG = {
    numSnakes: 6,
    numFood: 50,
    mutationRate: 0.2,
    maxLives: 3,
    initialZoneRadius: Math.max(canvas.width, canvas.height) / 1.3,
    numRays: 8, // Nombre de directions que l'IA regarde
    rayDistance: 300 // Port√©e de la vue
};

let zoneRadius = CONFIG.initialZoneRadius;

class NeuralNetwork {
    constructor(weights) {
        // Entr√©es : 8 rayons (nourriture) + 8 rayons (zone) + vitesse + angle = 18 entr√©es
        const inputSize = 18;
        this.weights = weights || Array.from({length: inputSize}, () => Math.random() * 2 - 1);
    }
    predict(inputs) {
        let sum = 0;
        inputs.forEach((val, i) => sum += val * this.weights[i]);
        return Math.tanh(sum) * 0.3; // Sortie entre -0.3 et 0.3 radians (virage)
    }
    mutate() {
        return new NeuralNetwork(this.weights.map(w => 
            Math.random() < CONFIG.mutationRate ? w + (Math.random() - 0.5) : w
        ));
    }
}

class Snake {
    constructor(id, brain) {
        this.id = id;
        this.brain = brain || new NeuralNetwork();
        this.fullReset();
    }

    fullReset() {
        this.lives = CONFIG.maxLives;
        this.score = 0;
        this.distanceTraveled = 0;
        this.respawn();
    }

    respawn() {
        this.x = canvas.width/2 + (Math.random()-0.5) * 100;
        this.y = canvas.height/2 + (Math.random()-0.5) * 100;
        this.angle = Math.random() * Math.PI * 2;
        this.currentWidth = 8;
        this.tail = [];
        this.length = 15;
        this.isAlive = true;
        this.viewData = []; // Pour le debug visuel
    }

    update(foods) {
        if (!this.isAlive) return;

        // --- CONSTRUCTION DE LA VISION ---
        let inputs = [];
        this.viewData = [];

        for (let i = 0; i < CONFIG.numRays; i++) {
            let rayAngle = this.angle + (i * Math.PI * 2 / CONFIG.numRays);
            let foodDist = 1; // 1 = rien vu, 0 = tr√®s proche
            let zoneDist = 1;

            // D√©tection nourriture sur ce rayon
            foods.forEach(f => {
                let dx = f.x - this.x;
                let dy = f.y - this.y;
                let dist = Math.hypot(dx, dy);
                let angleToFood = Math.atan2(dy, dx);
                let diff = Math.abs(rayAngle - angleToFood) % (Math.PI * 2);
                if (diff < 0.2 && dist < CONFIG.rayDistance) {
                    foodDist = Math.min(foodDist, dist / CONFIG.rayDistance);
                }
            });

            // D√©tection bord de zone sur ce rayon
            let rayX = this.x + Math.cos(rayAngle) * CONFIG.rayDistance;
            let rayY = this.y + Math.sin(rayAngle) * CONFIG.rayDistance;
            let distFromCenter = Math.hypot(rayX - canvas.width/2, rayY - canvas.height/2);
            if (distFromCenter > zoneRadius) zoneDist = 0.5; // Alerte zone proche

            inputs.push(foodDist);
            inputs.push(zoneDist);
            this.viewData.push({angle: rayAngle, dist: foodDist});
        }
        
        inputs.push(Math.cos(this.angle));
        inputs.push(Math.sin(this.angle));

        // IA d√©cide
        this.angle += this.brain.predict(inputs);

        // Physique
        this.x += Math.cos(this.angle) * 4;
        this.y += Math.sin(this.angle) * 4;
        this.distanceTraveled += 0.1; // R√©compense de survie minime

        // Mort par zone
        if (Math.hypot(this.x - canvas.width/2, this.y - canvas.height/2) > zoneRadius) {
            this.loseLife();
        }

        this.tail.unshift({x: this.x, y: this.y});
        if (this.tail.length > this.length) this.tail.pop();
    }

    loseLife() {
        this.lives--;
        if (this.lives > 0) this.respawn();
        else this.isAlive = false;
    }

    draw() {
        if (!this.isAlive) return;
        
        // Dessin des rayons de vision (optionnel, pour voir ce qu'il voit)
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        this.viewData.forEach(v => {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + Math.cos(v.angle) * 50, this.y + Math.sin(v.angle) * 50);
            ctx.stroke();
        });

        ctx.fillStyle = `hsl(${(this.id * 60)}, 70%, 50%)`;
        this.tail.forEach((p, i) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, this.currentWidth * (1 - i/this.tail.length * 0.4), 0, Math.PI*2);
            ctx.fill();
        });

        ctx.fillStyle = "white";
        ctx.font = "bold 12px Arial";
        ctx.fillText("IA-" + this.id, this.x - 15, this.y - 15);
    }
}

let snakes = Array.from({length: CONFIG.numSnakes}, (_, i) => new Snake(i + 1));
let foods = Array.from({length: CONFIG.numFood}, () => ({x: Math.random()*canvas.width, y: Math.random()*canvas.height}));
let generation = 1;
let highScore = 0;
let isSimulating = false;

function evolve() {
    // Score = Taille + Distance. Manger est beaucoup plus r√©compens√©.
    snakes.sort((a, b) => (b.length * 10 + b.distanceTraveled) - (a.length * 10 + a.distanceTraveled));
    let bestBrain = snakes[0].brain;
    if (snakes[0].length > highScore) highScore = snakes[0].length;

    snakes = snakes.map((s, i) => {
        return new Snake(i + 1, i === 0 ? bestBrain : bestBrain.mutate());
    });

    generation++;
    zoneRadius = CONFIG.initialZoneRadius;
}

async function runFastForward() {
    if (isSimulating) return;
    const iters = parseInt(document.getElementById('iterInput').value);
    isSimulating = true;
    document.getElementById('status').innerText = "Calcul de l'√©volution...";

    for (let i = 0; i < iters; i++) {
        while (snakes.some(s => s.isAlive)) {
            zoneRadius -= 0.5;
            snakes.forEach(s => {
                if (s.isAlive) {
                    s.update(foods);
                    foods.forEach(f => {
                        if (Math.hypot(s.x-f.x, s.y-f.y) < s.currentWidth + 10) {
                            s.length += 10; s.currentWidth += 0.3;
                            f.x = Math.random()*canvas.width; f.y = Math.random()*canvas.height;
                        }
                    });
                }
            });
            if (zoneRadius < 20) break;
        }
        evolve();
        if (i % 2 === 0) await new Promise(r => setTimeout(r, 1));
    }
    isSimulating = false;
    document.getElementById('status').innerText = "√âvolution termin√©e !";
}

function loop() {
    if (!isSimulating) {
        ctx.fillStyle = "black";
        ctx.fillRect(0,0, canvas.width, canvas.height);
        
        // Zone
        ctx.strokeStyle = "#e74c3c";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2, zoneRadius, 0, Math.PI*2);
        ctx.stroke();

        zoneRadius -= 0.15;
        if (zoneRadius < 30) zoneRadius = 30;

        if (!snakes.some(s => s.isAlive)) evolve();

        // Food
        ctx.fillStyle = "#2ecc71";
        foods.forEach(f => {
            ctx.beginPath(); ctx.arc(f.x, f.y, 5, 0, Math.PI*2); ctx.fill();
        });

        // Snakes
        snakes.forEach((s) => {
            s.update(foods);
            s.draw();
            foods.forEach(f => {
                if (s.isAlive && Math.hypot(s.x-f.x, s.y-f.y) < s.currentWidth + 8) {
                    s.length += 10; 
                    s.currentWidth += 0.3;
                    f.x = Math.random()*canvas.width; f.y = Math.random()*canvas.height;
                }
            });
        });

        // UI
        document.getElementById('gen').innerText = generation;
        document.getElementById('maxScore').innerText = Math.round(highScore);
        let html = "<b>STATISTIQUES IA</b><br><br>";
        snakes.forEach(s => {
            html += `ID ${s.id}: ${s.isAlive ? '‚ù§Ô∏è'.repeat(s.lives) : 'üíÄ'} | Taille: ${Math.round(s.length)}<br>`;
        });
        document.getElementById('playerStats').innerHTML = html;
    }
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
